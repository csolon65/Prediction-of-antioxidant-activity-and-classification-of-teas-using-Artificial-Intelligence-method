# -*- coding: utf-8 -*-
"""Prediction_CSMF.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EudYQpxlDaxPTaj640YgvYjnjZVieK9l
"""

import pandas as pd
import numpy as np

# Assurez-vous que Google Drive est monté et que le chemin d'accès au fichier est correct
from google.colab import drive
drive.mount('/content/drive')
directory_path = "/content/drive/My Drive/"
filename = 'DPPH.csv'
file_path = directory_path + filename  # Chemin complet vers le fichier

# Définition des équations pour ECG, Épicatéchine et Trolox
ecg_equation = {'m': 6.285, 'b': 1516.2}
epi_equation = {'m': 9.8513, 'b': 74.903}
trolox_equation = {'m': 7.0188, 'b': 1011.1}

# Fonctions pour calculer les concentrations et l'absorbance
def concentration_from_asc(asc, equation):
    m, b = equation['m'], equation['b']
    concentration = (asc - b) / m
    # Gestion des concentrations négatives : si la concentration est inférieure à 0, on l'extrapole à 0
    # Cela permet de conserver les valeurs zéro et de traiter correctement les valeurs sous b
    return max(0, concentration)

def area_from_concentration(concentration, equation):
    m, b = equation['m'], equation['b']
    area = m * concentration + b
    return area

# Chargement du fichier CSV contenant les données ASC pour ECG et Épicatéchine pour tous les thés
asc_data = pd.read_csv(file_path, delimiter=';', header=0)

# Renommer les colonnes pour correspondre aux noms attendus dans vos fonctions
asc_data.rename(columns=lambda x: x.strip(), inplace=True)

# Calculer les concentrations pour chaque antioxydant
for col in asc_data.columns[1:]:  # On saute la première colonne qui contient les noms des antioxydants
    # Les noms de colonnes sont directement les noms d'échantillons comme V1, V2, etc.
    asc_data[col + '_ECG_Conc'] = asc_data.apply(lambda x: concentration_from_asc(x[col], ecg_equation) if x['Antioxydants'] == 'ECG' else np.nan, axis=1)
    asc_data[col + '_Epi_Conc'] = asc_data.apply(lambda x: concentration_from_asc(x[col], epi_equation) if x['Antioxydants'] == 'Épicatéchine' else np.nan, axis=1)

    # Calculer les valeurs d'absorbance équivalentes à Trolox pour chaque échantillon
    asc_data[col + '_ECG_Trolox'] = asc_data[col + '_ECG_Conc'].apply(lambda x: area_from_concentration(x, trolox_equation) if pd.notnull(x) else np.nan)
    asc_data[col + '_Epi_Trolox'] = asc_data[col + '_Epi_Conc'].apply(lambda x: area_from_concentration(x, trolox_equation) if pd.notnull(x) else np.nan)

# Sauvegarder les résultats dans un nouveau fichier CSV
asc_data.to_csv(directory_path + 'resultat_concentrations_trolox.csv', index=False)

import pandas as pd
import numpy as np

# Assurez-vous que Google Drive est monté et que le chemin d'accès au fichier est correct
from google.colab import drive
drive.mount('/content/drive')
directory_path = "/content/drive/My Drive/"
filename = 'T230.csv'
file_path = directory_path + filename  # Chemin complet vers le fichier

# Définition des équations pour ECG, Épicatéchine et Trolox
ecg_equation = {'m': 63.509, 'b': 562.51}
epi_equation = {'m': 42.945, 'b':2952.8 }
trolox_equation = {'m': 27.27, 'b': -1849.5}

# Fonctions pour calculer les concentrations et l'absorbance
def concentration_from_asc(asc, equation):
    m, b = equation['m'], equation['b']
    concentration = (asc - b) / m
    # Gestion des concentrations négatives : si la concentration est inférieure à 0, on l'extrapole à 0
    # Cela permet de conserver les valeurs zéro et de traiter correctement les valeurs sous b
    return max(0, concentration)

def area_from_concentration(concentration, equation):
    m, b = equation['m'], equation['b']
    area = m * concentration + b
    return area

# Chargement du fichier CSV contenant les données ASC pour ECG et Épicatéchine pour tous les thés
asc_data = pd.read_csv(file_path, delimiter=';', header=0)

# Renommer les colonnes pour correspondre aux noms attendus dans vos fonctions
asc_data.rename(columns=lambda x: x.strip(), inplace=True)

# Calculer les concentrations pour chaque antioxydant
for col in asc_data.columns[1:]:  # On saute la première colonne qui contient les noms des antioxydants
    # Les noms de colonnes sont directement les noms d'échantillons comme V1, V2, etc.
    asc_data[col + '_ECG_Conc'] = asc_data.apply(lambda x: concentration_from_asc(x[col], ecg_equation) if x['Antioxydants'] == 'ECG' else np.nan, axis=1)
    asc_data[col + '_Epi_Conc'] = asc_data.apply(lambda x: concentration_from_asc(x[col], epi_equation) if x['Antioxydants'] == 'Épicatéchine' else np.nan, axis=1)

    # Calculer les valeurs d'absorbance équivalentes à Trolox pour chaque échantillon
    asc_data[col + '_ECG_Trolox'] = asc_data[col + '_ECG_Conc'].apply(lambda x: area_from_concentration(x, trolox_equation) if pd.notnull(x) else np.nan)
    asc_data[col + '_Epi_Trolox'] = asc_data[col + '_Epi_Conc'].apply(lambda x: area_from_concentration(x, trolox_equation) if pd.notnull(x) else np.nan)

# Sauvegarder les résultats dans un nouveau fichier CSV
asc_data.to_csv(directory_path + 'resultat_concentrations_trolox.csv', index=False)

asc_data.head()

from google.colab import files

asc_data.to_csv('asc_data.csv', index=False)

# Use the files.download command to trigger a download prompt in the browser.
files.download('asc_data.csv')